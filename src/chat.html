<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  </head>
  <body>
    <!-- Cursor based on https://github.com/liveblocks/liveblocks/blob/main/examples/javascript-live-cursors/static/index.html -->
    <svg
      id="cursor-template"
      style="position: absolute; left: 0; top: 0; transition: transform 0.3s cubic-bezier(0.17, 0.93, 0.38, 1)"
      width="24"
      height="36"
      viewBox="0 0 24 36"
      fill="transparent"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path d="M 8.553 13.433 L 11.511 19.256 L 9.083 20.717 L 6.176 14.382 L 2.433 17.229 L 2.433 1.544 L 12.79 12.907 L 8.553 13.433 Z"/>
    </svg>

    <!-- Shared container -->
    <div id="container" style="height:300px; width:300px; border: 1px solid red; overflow-y: scroll"></div>

    <script src="https://unpkg.com/ulid@2.3.0/dist/index.umd.js"></script>

    <script type="text/javascript">
    let currentWebSocket = null;
    let username = `${ULID.ulid()}:robert`;
    let roomname = "test";
    let hostname = window.location.host;

    // Source: https://github.com/d3/d3-scale-chromatic/blob/main/src/categorical/category10.js
    const COLORS = ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"]

    

    // ---------------------------------------------------------------------------
    // WebSocket Management
    // ---------------------------------------------------------------------------

    function join() {
      let ws = new WebSocket("wss://" + hostname + "/api/room/" + roomname + "/websocket");
      let rejoined = false;
      let startTime = Date.now();

      let rejoin = async () => {
        if (!rejoined) {
          rejoined = true;
          currentWebSocket = null;

          // Don't try to reconnect too rapidly.
          let timeSinceLastJoin = Date.now() - startTime;
          if (timeSinceLastJoin < 1000)
            await new Promise(resolve => setTimeout(resolve, 1000 - timeSinceLastJoin));
          join();
        }
      }

      // When open connection, send user's name
      ws.addEventListener("open", event => {
        currentWebSocket = ws;
        ws.send(JSON.stringify({ name: username }));
      });

      // Process incoming messages
      ws.addEventListener("message", event => {
        let data = JSON.parse(event.data);

        if (data.error) {
          addChatMessage(null);
          console.error("ERROR:", data.error)
        } else if (data.joined) {
          console.warn("JOINED", data);
        } else if (data.quit) {
          console.warn("QUIT", data);
          let cursor = document.getElementById(`cursor-${data.quit}`);
          if (cursor != null) {
            cursor.remove()
          }
        } else if (data.ready) {
          console.log("Ready.")
        } else {
          addChatMessage(data);
        }
      });

      ws.addEventListener("close", event => {
        console.log("WebSocket closed, reconnecting:", event.code, event.reason);
        rejoin();
      });
      ws.addEventListener("error", event => {
        console.log("WebSocket error, reconnecting:", event);
        rejoin();
      });
    }

    // ---------------------------------------------------------------------------
    // Update cursors
    // ---------------------------------------------------------------------------

    function addChatMessage(data) {
      if(data.name === username)
        return;

      let cursor = document.getElementById(`cursor-${data.name}`);
      if (cursor == null) {
        cursor = document.getElementById("cursor-template").cloneNode(true);
        cursor.id = `cursor-${data.name}`;
        cursor.style.fill = getColor(data.name);
        document.body.appendChild(cursor);
      }

      if(data.cursor.x != null && data.cursor.y != null) {
        cursor.style.transform = `translateX(${data.cursor.x}px) translateY(${data.cursor.y}px)`;
        cursor.style.opacity = "1";
      } else {
        cursor.style.opacity = "0";
      }
    }


    // ---------------------------------------------------------------------------
    // Utilities
    // ---------------------------------------------------------------------------

    // Generate a color from a user ID
    function getColor(user) {
      return COLORS[Math.abs(user.hash()) % COLORS.length]
    }

    // Debounce. Source: https://github.com/m-gagne/limit.js/blob/master/limit.js
    Function.prototype.debounce = function(milliseconds, context) {
        var baseFunction = this, timer = null, wait = milliseconds;
        return function () {
            var self = context || this, args = arguments;
            function complete() { baseFunction.apply(self, args); timer = null; }
            if(timer)
                clearTimeout(timer);
            timer = setTimeout(complete, wait);
        };
    };

    // Hashing function. Source: https://stackoverflow.com/a/7616484
    String.prototype.hash = function() {
      var hash = 0, i, chr;
      if (this.length === 0) return hash;
      for (i = 0; i < this.length; i++) {
        chr   = this.charCodeAt(i);
        hash  = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    };


    // ---------------------------------------------------------------------------
    // Event handlers
    // ---------------------------------------------------------------------------

    // On page load
    document.addEventListener("DOMContentLoaded", function () {
      join();
    });

    // When user moves their pointer
    document.getElementById("container").addEventListener("pointermove", function (e) {
      let x = e.clientX, y = e.clientY;
      // Detect going outside the container
      // TODO: use container's actual size
      if(x > 300 || y > 300) {
        x = null;
        y = null;
      }
      currentWebSocket.send(JSON.stringify({ cursor: { x, y } }));
    }.debounce(10));

    // When user leaves container area
    document.getElementById("container").addEventListener("pointerleave", function (e) {
      let x = e.clientX, y = e.clientY;
      // TODO: user container's actual size
      if(x <= 300 || y <= 300)
        return
      currentWebSocket.send(JSON.stringify({ cursor: { x: null, y: null } }));
    }.debounce(10));

    // When leave or refresh page
    document.addEventListener("unload", function(e){
      currentWebSocket.send(JSON.stringify({ cursor: { x: null, y: null } }));
    });
    </script>
</html>
